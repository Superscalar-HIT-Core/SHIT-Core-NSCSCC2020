# SHIT-Backend

## 总体概述

- 后端：和前端通过Fetch Buffer进行交互，给前端清除和重定向信号。

- 功能单元划分：
    - 整数单元\*2（分支指令、整数指令），允许分支指令乱序发射
    - LSU：主要工作在于Cache，需要实现写缓冲和非阻塞Cache
    - MDU：主要工作在与乘除法的优化（其中乘法需要高度流水化，除法需要短周期，考察CoreMark测试程序得出的结果）


- 后端流水线切分：
    - 译码 
    - 重命名 (较复杂，需要单独一级)
    - 分发+写ROB （路由较复杂，需要单独一级）
    - 发射（乱序开始）：需要一个寄存器接收出来的指令
    - 读寄存器
    - 执行
    - 写回


## 更新日志

### 2020-07-12

- Dispatch 模块（Todo：把decode ops搞定）

### 测试通过

- 重命名模块、发射队列模块资源占用尚可接受



### 2020-07-11

- 修改FreeList, BusyTable，Maptable保证0号寄存器不被分配，在寄存器重命名的时候，如果目的寄存器的0号寄存器，则不请求重命名，0号寄存器永远被映射到物理的0号寄存器
- Free List保证不分配出0号寄存器，Busy Table保证0号寄存器永远不Busy
- 重命名连线的时候需要保证0号寄存器的判断，如果是0，则不能向free list去请求（相当于在结构体中，`wreg`一项是0）。
- 完成指令队列的建模

### 测试通过

- 寄存器重命名模块（充分测试）

### 计划

- 直接使用去年的译码模块，需要添加的是在译码时确定指令队列的编号
- 实现简单的仲裁逻辑
- 先使用去年的执行模块
- 发射队列仲裁的时候，需要实现Pass-through队列
- 旁路问题还需要好好考虑，是否真正需要实现旁路逻辑，因为写回和执行在同一个周期了（还是不能在一个周期？写回寄存器单独一个流水级，否则逻辑太复杂了）
- 想法：Store指令顺序发射，而Load指令可以乱序，则Store的队列中需要添加一个Mask向量，为1表示Store指令，当某一个Bit为1的时候，后面的所有指令都不能发射
- 明天考虑一下旁路的事情，后天把执行模块完成了

### 2020-07-08

- 完成压缩队列的原型

- 完成压缩队列中指令槽的原型

- 主要工作在于优化电路的逻辑层数，自己通过真值表来化简逻辑表达式，避免使用Verilog自带的逻辑always @(\*)

#### 测试通过

- 压缩队列原型的入队和出队

#### 计划

- 译码模块：完成指令操作码的译码 

- 完成ROB的模型：主要难点在于如何让分支指令和延迟槽一起提交，同时需要配合testbench进行

- 完成仲裁逻辑（简单）


### 2020-07-07

- 完成重命名映射表 / Free List

#### 测试通过

- Free List的分配与回收、恢复

#### 计划

- 完成指令队列


## 问题列表

- 延迟槽指令需要同时和分支指令进入（Fetch Buffer必须保证）

- 延迟槽指令需要保证分支指令提交之后进行提交

- 和前端商定分支预测结果和方向的接口，以便后端进行重定向操作

- 由于流水线层级较深，应努力提高分支预测准确度

- 对于CP0指令和Uncached指令，必须顺序发射，类似于ssnop，这一点如何保证？【初步想法：需要ROB的信号，ROB为空的时候，就保证是顺序发射】

