# SHIT-Backend

## 总体概述

- 任务：需要添加推测唤醒和旁路
- 修改：LSU到ALU的旁路，ALU到LSU的旁路（到LSU的第一阶段，第二阶段由于是访问存储器，访问的地址已经计算出来了，所以不能旁路到第二阶段）
- LOAD指令的推测唤醒，Store指令的提前唤醒（已经完成），Store可以再提前一个周期唤醒，因为可以旁路到LSU第一阶段（TAG访问））
- LOAD唤醒失败的撤回：需要撤回流水线中位于Issue/RF, RF/EX阶段的指令，其方法是Flush流水线，并且将Scoreboard恢复到2周期（或者n周期之前的）；也就意味着，在每一次发射Load的时候，都需要对Scoreboard做一次的Snapshot，这个Snapshot是FIFO结构，如果唤醒成功就会被覆盖

- 后端：和前端通过Fetch Buffer进行交互，给前端清除和重定向信号。

- 功能单元划分：
    - 整数单元\*2（分支指令、整数指令），允许分支指令乱序发射
    - LSU：主要工作在于Cache，需要实现写缓冲和非阻塞Cache
    - MDU：主要工作在与乘除法的优化（其中乘法需要高度流水化，除法需要短周期，考察CoreMark测试程序得出的结果）


- 后端流水线切分：
    - 译码 
    - 重命名 (较复杂，需要单独一级)
    - 分发+写ROB （路由较复杂，需要单独一级）
    - 发射（乱序开始）：需要一个寄存器接收出来的指令
    - 读寄存器
    - 执行
    - 写回

- file copy -force ../../../soft/perf_func/obj/stream_copy/axi_ram.mif ./mycpu.sim/sim_1/behav/xsim/axi_ram.mif; restart; run all;

- cd [get_property DIRECTORY [current_project]]; source ./run_allbench.tcl
## 更新日志

### 2020-07-31 

- 添加分支预测，使用AXI Interconnect代替原有的仲裁逻辑

### 2020-07-29

- 功能测试上板通过，性能测试仍然有bug

### 2020-07-25

- 主体架构基本完成，正在进行官方的功能测试
- CP0和异常模块暂未测试，CP0指令单发已经测试完毕
- 需要对异常进行测试
- 需要进行**代码审查**，防止复制粘贴的错误发生

#### TODO

- 前端取指时地址不对齐异常需要传递，输出指令是NOP
- LSU需要给出ADEL和ADES异常

### 2020-07-15

- 逻辑寄存器的索引改为34个，6位，包括Hi/Lo寄存器；其中Hi对应的是32，Lo对应的是33.
  - 需要改动：逻辑寄存器编号的位宽


### 2020-07-12

- Dispatch 模块（Todo：把decode ops搞定）

### 测试通过

- 重命名模块、发射队列模块资源占用尚可接受



### 2020-07-11

- 修改FreeList, BusyTable，Maptable保证0号寄存器不被分配，在寄存器重命名的时候，如果目的寄存器的0号寄存器，则不请求重命名，0号寄存器永远被映射到物理的0号寄存器
- Free List保证不分配出0号寄存器，Busy Table保证0号寄存器永远不Busy
- 重命名连线的时候需要保证0号寄存器的判断，如果是0，则不能向free list去请求（相当于在结构体中，`wreg`一项是0）。
- 完成指令队列的建模

### 测试通过

- 寄存器重命名模块（充分测试）

### 计划

- 直接使用去年的译码模块，需要添加的是在译码时确定指令队列的编号
- 实现简单的仲裁逻辑
- 先使用去年的执行模块
- 发射队列仲裁的时候，需要实现Pass-through队列
- 旁路问题还需要好好考虑，是否真正需要实现旁路逻辑，因为写回和执行在同一个周期了（还是不能在一个周期？写回寄存器单独一个流水级，否则逻辑太复杂了）
- 想法：Store指令顺序发射，而Load指令可以乱序，则Store的队列中需要添加一个Mask向量，为1表示Store指令，当某一个Bit为1的时候，后面的所有指令都不能发射
- 明天考虑一下旁路的事情，后天把执行模块完成了

### 2020-07-08

- 完成压缩队列的原型

- 完成压缩队列中指令槽的原型

- 主要工作在于优化电路的逻辑层数，自己通过真值表来化简逻辑表达式，避免使用Verilog自带的逻辑always @(\*)

#### 测试通过

- 压缩队列原型的入队和出队

#### 计划

- 译码模块：完成指令操作码的译码 

- 完成ROB的模型：主要难点在于如何让分支指令和延迟槽一起提交，同时需要配合testbench进行

- 完成仲裁逻辑（简单）


### 2020-07-07

- 完成重命名映射表 / Free List

#### 测试通过

- Free List的分配与回收、恢复

#### 计划

- 完成指令队列


## 问题列表

- 延迟槽指令需要同时和分支指令进入（Fetch Buffer必须保证）

- 延迟槽指令需要保证分支指令提交之后进行提交

- 和前端商定分支预测结果和方向的接口，以便后端进行重定向操作

- 由于流水线层级较深，应努力提高分支预测准确度

- 对于CP0指令和Uncached指令，必须顺序发射，类似于ssnop，这一点如何保证？【初步想法：需要ROB的信号，ROB为空的时候，就保证是顺序发射】

